import { PostLayout, CodeWindow } from "@/components/layout";

export const meta = {
  date: "2024-02-11",
  title: "Role-Based Access Control (RBAC) in a React",
  description:
    "Role-Based Access Control (RBAC) is a method of restricting access to certain parts of an application based on the user's role. It's a critical component in any application that has different levels of user permissions and access requirements",
  image: "/images/blog/rbac-react/rbac-react-intro.jpg",
  tags: ["Architecture", "Security", "React"],
  type: "blog"
};

export default (props) => <PostLayout meta={meta} {...props} />;

Role-Based Access Control (RBAC) is a method of restricting access to certain parts of an application based on the user's role. It's a critical component in any application that has different levels of user permissions and access requirements.

## Why RBAC?

RBAC helps in:

- Enhancing security by limiting access to sensitive information and functionality
- Simplifying user management by grouping permissions based on roles rather than individual users
- Providing a scalable and maintainable way to handle user permissions

## Setting Up RBAC in React

We'll walk through a simple example to demonstrate how to set up RBAC in a React application. For this example, we'll assume we have three roles: `Admin`, `Editor`, and `Viewer`.
Each role will have different access permissions.

### Step 1: Define Roles and Permissions

First, we need to define the roles and their respective permissions. This can be done using a simple JavaScript object.

<CodeWindow>
```TSX
// src/roles.js

const roles = {
  ADMIN: 'admin',
  EDITOR: 'editor',
  VIEWER: 'viewer',
};

const permissions = {
  [roles.ADMIN]: ['read', 'write', 'delete'],
  [roles.EDITOR]: ['read', 'write'],
  [roles.VIEWER]: ['read'],
};
````
</CodeWindow>

### Step 2: Create a Higher-Order Component (HOC) for RBAC

Next, we'll create a Higher-Order Component (HOC) that will wrap our protected components and check if the user has the required permissions to access them.

<CodeWindow>
```TSX
// src/wrapper.js

import React from 'react';
import { Redirect } from 'react-router-dom';

const withAuthorization = (allowedRoles) => (WrappedComponent) => {
  return class WithAuthorization extends React.Component {
    render() {
      const { role } = this.props; // Assume role is passed as a prop

      if (allowedRoles.includes(role)) {
        return <WrappedComponent {...this.props} />;
      } else {
        return <Redirect to="/unauthorized" />;
      }
    }
  };
};

export default withAuthorization;
````
</CodeWindow>

### Step 3: Use the HOC to Protect Routes
Now we can use our withAuthorization HOC to protect our routes or components.

<CodeWindow>
```TSX
// src/routes.js

import React from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import withAuthorization from './withAuthorization';

const AdminPage = () => <div>Admin Page</div>;
const EditorPage = () => <div>Editor Page</div>;
const ViewerPage = () => <div>Viewer Page</div>;
const UnauthorizedPage = () => <div>Unauthorized</div>;

const App = () => {
  const userRole = 'editor'; // This should come from your user state (e.g., context, redux)

  return (
    <Router>
      <Switch>
        <Route
          path="/admin"
          component={withAuthorization([roles.ADMIN])(AdminPage)}
        />
        <Route
          path="/editor"
          component={withAuthorization([roles.ADMIN, roles.EDITOR])(EditorPage)}
        />
        <Route
          path="/viewer"
          component={withAuthorization([roles.ADMIN, roles.EDITOR, roles.VIEWER])(ViewerPage)}
        />
        <Route path="/unauthorized" component={UnauthorizedPage} />
      </Switch>
    </Router>
  );
};

export default App;
````
</CodeWindow>

## Conclusion
Implementing Role-Based Access Control (RBAC) in your React application is a straightforward way to enhance security and manage user permissions effectively.
By defining clear roles and permissions, creating a Higher-Order Component (HOC) to handle authorization, and protecting your routes accordingly, you ensure that users can only access what they're allowed to.

With this approach, not only do you make your application more secure, but you also simplify user management and create a more organized codebase.
This method is scalable, making it easier to maintain and update as your application grows.

Remember, security and proper user access control are crucial for any application. By following the steps outlined in this post, you can implement a robust RBAC system in your React projects, providing a better and safer experience for your users.